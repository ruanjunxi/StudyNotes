## 基础篇

#### 执行一条select语句，期间发生了什么？（mysql的架构）

mysql的架构包含两层：**Server 层和存储引擎层**

- Server 层负责建立连接、分析和执行sql语句。
- 存储引擎层负责数据的存储和提取。

**第一步：连接器**

- 与客户端进行 TCP 三次握手建立连接；
- 校验客户端的用户名和密码，如果用户名或密码不对，则会报错；
- 如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；

第二步：查询缓存

- 缓存是以key-value形式保存的，key为查询的语句，value为返回结果；
- 缓存的命中率是很低的：
  - 查询语句要完全相同才能命中缓存；
  - 只要一个表有更新操作，那么它所有的缓存将被清空，从而导致命中率低。

第三步：解析sql

-  包含词法分析与语法分析

第四步：执行sql

- 预处理阶段：
  - 检查 SQL 查询语句中的表或者字段是否存在；
  - 将 `select *` 中的 `*` 符号，扩展为表上的所有列；

- 优化阶段
  - **优化器主要负责将 SQL 查询语句的执行方案确定下来**，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。
- 执行阶段
  - 主键索引查询
  - 全表扫描
  - 索引下推

## 索引篇

#### 索引的分类

- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。 
- 按「字段个数」分类：**单列索引、联合索引**。

**前缀索引：**是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。

**联合索引：**对多个字段建立一个索引，使用联合索引时，存在**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。**注：利用索引的前提是索引里的 key 是有序的。**例：对于语句``` select * from t_table where a > 1 and b = 2，a > 1 是可以使用到索引的，但是对于a > 1 的部分b是无序的，因此b=2是无法使用到索引。如果where条件改为a>=1，那么在a=1的情况下b是有序的，是可以用到索引的，那么 此时a,b都用到了索引。``` 综上所示，**联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配，前面我也用了四个例子说明了**。

#### 索引下推：

**索引下推（Index Condition Pushdown）** 是 **MySQL 5.6** 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。具体而言，索引下推将查询条件下推到存储引擎层面，在引擎内部使用索引来过滤和检索数据，而不是在数据库服务器中进行。这样可以避免将大量不必要的数据加载到内存中，并减少对磁盘访问的次数。索引下推的优势在于能够减少I/O开销、减小网络传输和降低CPU负载。通过减少需要处理的数据量，可以加快查询速度，提高系统的响应性能。

#### 适合做索引的字段

- 不为null的字段
- 被频繁查询的字段
- 被频繁用做条件查询的字段
- 频繁需要排序的字段

#### 索引失效情况

- 创建了联合索引，但查询条件未准守最左匹配原则;
- 使用左模糊查询如 like '%A';
- 在索引列上进行计算、函数、类型转换等操作;
- 查询条件中带有or，且or中含有非索引字段，那么索引会失效；

## 事务篇

#### 事务的特性

事务包含四个特性ACID，如下：

- **原子性（Atomicity）**：事务中的操作要么全部执行要么全部不执行。（使用undo log来实现）
- **一致性（Consistency）**：事务执行前后，数据库的保持一致性状态。（业务层面来实现，数据库层面的话就是主键约束，唯一约束等）
- **隔离性（Isolation）**：数据库允许多个事务并发执行，一个用户的事务不被其他事务所干扰，即各并发事务之间数据库是独立的。（四个隔离级别来实现）
- **持久性（Durability）**：一个事物被提交，对数据库中数据的改变是持久的。（redolog来实现）

#### 并发事务引出的问题

包括：脏读、不可重复读、幻读的问题。

- 脏读：一个事务读取到了另一个未提交事务修改过的数据。
- 不可重复读：一个事务前后两次读取同一个数据，但两次读到的数据不同，就意味着发生了不可重复读。
- 幻读：一个事务内多次查询符合某个条件的记录数，前后两次查询的记录数不同，就意味着发生了幻读。

#### 事务的隔离级别

SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：

- **读未提交（*read uncommitted*）**，指一个事务还没提交时，它做的变更就能被其他事务看到；
- **读提交（*read committed*）**，指一个事务提交之后，它做的变更才能被其他事务看到；（解决脏读）
- **可重复读（*repeatable read*）**，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，**MySQL InnoDB 引擎的默认隔离级别**；（解决不可重复读）
- **串行化（\*serializable\* ）**；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；（解决幻读）

**MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象**，解决方案有两种：

- 针对**快照读**（普通 select 语句），通过**MVCC**的方式解决了幻读，即事务执行过程中看到的数据与启动该事务时看到的数据一致。
- 针对**当前读**（select ... for update 等语句），是**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

##### 可重复读是如何工作的

可重复读隔离级别是启动事务时生成一个read view，整个事务期间都使用这个read view。

##### 读提交是如何工作的

**读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View**。也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。

#### 事务的并发控制

MySQL 中并发事务的控制方式无非就两种：**锁** 和 **MVCC**。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。

1. **共享锁（S 锁）**：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。

   **排他锁（X 锁）**：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。

2. **MVCC** 通过在数据库中存储多个版本数据来实现并发控制，通过事务的可见性来保证事务只能看到属于自己的版本。MVCC 在 MySQL 中实现所依赖的手段主要是: **隐藏字段、read view、undo log**。

   - undo log 用于存储某行记录的多个版本的数据；
   - 隐藏字段和read view 用于判断当前版本数据的可见性

### 总结

当多个事务并发执行时，会引发脏读、不可重复读、幻读等问题，为了避免这些问题。SQL提出四种隔离级别：读未提交、读提交、可重复读、串行化，隔离级别依次提升。要解决脏读，就要达到读提交级别；要解决不可重复读，就要达到可重复读级别，不建议升级为串行化来解决幻读问题。MYSQL默认是可重复读级别，可以很大程度上减少幻读情况。

对于「读提交」和「可重复读」隔离级别的事务来说，它们是通过 Read View 来实现的，它们的区别在于创建 Read View 的时机不同：

- **读提交**是在每个select时都会生成一个 Read View，这也意味着事务执行期间，多次读取数据可能会不一致，这是因为另一个事务修改了这个数据并提交了该事务。
- **可重复读**是在启动事务时就会生成一个 Read View，并在整个事务执行期间都使用这个 Read View，这样就保证了事务期间使用的数据都是事务启动时的数据。

这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列」的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。

在可重复读隔离级别中，普通的 select 语句就是基于 MVCC 实现的快照读，也就是不会加锁的。而 select .. for update 语句就不是快照读了，而是当前读了，也就是每次读都是拿到最新版本的数据，但是它会对读到的记录加上 next-key lock 锁。

## 锁篇

包括全局锁、表级锁、行级锁、

#### 全局锁

全局锁主要应用于做**全库逻辑备份**，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

#### 表级锁

- **表锁**
- **元数据锁**（MDL）：MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。我们不需要手动添加MDL，当我们对数据库表进行操作时，会自动上锁：
  - 对一张表进行 CRUD 操作时，加的是 **MDL 读锁**；
  - 对一张表做结构变更操作的时候，加的是 **MDL 写锁**；
- **意向锁**：分为意向共享锁和意向独占锁。他们均是表级锁，不会和行级锁发生冲突，而且意向锁之间也不会发生冲突。
  - 如果没了意向锁，那么要加独占表锁的话就要遍历整个表，查看是否有记录存在独占锁
  - 有了意向锁，由于在加独占锁之前会先加意向独占锁，那么在加独占表锁时，只需检查是否有意向独占锁即可。
  - 所以，**意向锁的目的是为了快速判断表里是否有记录被加锁**。
- **AUTO-INC 锁**：主要用于实现主键自增

#### 行级锁

InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：

- 记录锁**（Record Lock）**：对单个行上锁
- 间隙锁**（Gap Lock）**：锁定一个范围，不包括记录本身
- **临键锁（Next-Key Lock）**：Record Lock+Gap Lock，锁定一个范围，包括记录本身，主要目的是为了解决幻读问题。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。

## 日志篇

#### undo log

事务使用undo log来保证其原子性。每当 InnoDB 引擎对一条记录进行操作（修改、删除、新增）时，要把回滚时需要的信息都记录到 undo log 里，比如：

- 在**插入**一条记录时，要把这条记录的主键值记下来，这样之后回滚时只需要把这个主键值对应的记录**删掉**就好了；
- 在**删除**一条记录时，要把这条记录中的内容都记下来，这样之后回滚时再把由这些内容组成的记录**插入**到表中就好了；
- 在**更新**一条记录时，要把被更新的列的旧值记下来，这样之后回滚时再把这些列**更新为旧值**就好了。

另外，**undo log 还有一个作用，通过 ReadView + undo log 实现 MVCC（多版本并发控制）**。

因此，undo log两大作用：

1. **实现事务回滚，保障事务的原子性**。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。
2. **实现 MVCC（多版本并发控制）关键因素之一**。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。

#### redo log

redo log 是物理日志，记录了某个数据页做了什么修改，比如**对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了AAA 更新**，每当执行一个事务就会产生这样的一条或者多条物理日志。在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。

为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 **redo log** 的形式记录下来，**这个时候更新就算完成了**。后续，InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 **WAL （Write-Ahead Logging）技术**。**WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上**。

**undo log 和 redo log 的区别：**

- redo log 记录了此次事务「**完成后**」的数据状态，记录的是更新**之后**的值；
- undo log 记录了此次事务「**开始前**」的数据状态，记录的是更新**之前**的值；

**总结：redo log 的两个作用：**

- **实现事务的持久性，让 MySQL 有 crash-safe 的能力**，能够保证 MySQL 在任何时间段突然崩溃，重启后之前已提交的记录都不会丢失；
- **将写操作从「随机写」变成了「顺序写」**，提升 MySQL 写入磁盘的性能。

#### bin log

前面的undo log 和 redo log都是innodb存储引擎生成的，binlog是由Mysql 在server层实现的。binlog记录了所有数据库表结构的变化操作以及数据的变化操作。可见 binlog 和 redo log相近。

`binlog` 日志有三种格式，可以通过`binlog_format`参数指定。

- **statement：**记录的内容是`SQL`语句原文，同步数据时可以直接执行这些语句`SQL`。但有个问题，如果有` update_time=now()` 语句，那么时间会对不上，为了解决这个问题，可以指定格式为` row`。
- **row：**记录的内容不再是简单的`SQL`语句了，还包含操作的具体数据，记录内容如下。![RAW](.\ref\RAW.jpg)

- **mixed：**前两种的混合。`MySQL`会判断这条`SQL`语句是否可能引起数据不一致，如果是，就用`row`格式，否则就用`statement`格式。

区别如下：

- 适用对象不同：binlog所有存储引擎均可使用，redo log是Innodb独有的。
- 文件格式不同：binlog是逻辑日志，

**主从复制**

Mysql的主从复制依赖于binlog，复制过程就是将主库上的binlog同步给从库，可以分为三个阶段：

- **写入 Binlog**：主库写 binlog 日志，提交事务，并更新本地存储数据。
- **同步 Binlog**：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。
- **回放 Binlog**：回放 binlog，并更新从库中的数据。

具体过程如下：

- Mysql在收到客户端提交事务的请求时，会先写入binlog，然后在提交事务，更新数据。事务提交完成后，给客户端返回确认消息。
- 从库会创建一个I/O线程用于连接主库的log dump线程，来接收主库的binlog，再把内容写入relay log中。
- 从库会创建一个用于回放binlog的线程用于将relay log中的数据回放到自己的binlog中，然后在用本地的binlog来更新从库。

**主从复制模型**

- **同步复制**：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式在实际项目中，基本上没法用，原因有两个：一是性能很差，因为要复制到所有节点才返回响应；二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。
- **异步复制**（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。
- **半同步复制**：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。这种**半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险**。

**二阶段提交**

`redo log`（重做日志）让`InnoDB`存储引擎拥有了崩溃恢复能力。`binlog`（归档日志）保证了`MySQL`集群架构的数据一致性。

在语句执行过程中会记录这两个日志文件，以基本的事务为单位，`redo log`在事务执行时会不断写入，而`binlog`是在事务提交时才写入，因此二者写入时机不一致，那么就会产生如下问题：

当事务正常执行准备提交时，数据库发生了宕机，即此时`redo log`已经完成了该事务的记录，而`binlog`中却没有。因此当数据库重启恢复后，主库会根据`redo log`来恢复数据，而从库同步到主库的`binlog`中并没有该事务涉及的更新操作，从而导致主从库数据不一致问题。为了解决两份日志之间的逻辑一致问题，`InnoDB`存储引擎使用**两阶段提交**方案。

原理很简单，将`redo log`的写入拆成了两个步骤`prepare`和`commit`，一开始写入`redo log`时设置为prepare状态，当`binlog`也写入后，再将`redo log`状态改为commit，这就是**两阶段提交**。使用**两阶段提交**后，写入`binlog`时发生异常也不会有影响，因为`MySQL`根据`redo log`日志恢复数据时，发现`redo log`还处于`prepare`阶段，并且没有对应`binlog`日志，就会回滚该事务。

