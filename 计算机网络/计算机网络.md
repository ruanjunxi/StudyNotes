###  HTTP VS HTTPS

####  HTTP（Hypertext Transfer Protocol

**HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。**

1.1.2 HTTP 协议通信过程

HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：

- 服务器在 80 端口等待客户的请求。
- 浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。
- 服务器接收来自浏览器的 TCP 连接。
- 浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。
- 关闭 TCP 连接

#### HTTPS（Hyper Text Transfer Protocol Secure）

HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443。HTTPS 之所以能达到较高的安全性要求，就是结合了 SSL/TLS 和 TCP 协议，对通信数据进行加密，解决了 HTTP 数据透明的问题。主要解决以下三个风险：

- **窃听风险**，比如通信链路上可以获取通信内容，用户号容易没。解决方案：**混合加密**的方式实现信息的**机密性**，解决了窃听的风险。
- **篡改风险**，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。解决方案：**摘要算法**的方式来实现**完整性**，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。
- **冒充风险**，比如冒充淘宝网站，用户钱容易没。解决方案：将服务器公钥放入到**数字证书**中，解决了冒充的风险。

1. *混合加密*
   HTTPS采用**对称加密**和**非对称加密**结合的「混合加密」方式：

   - 在通信建立前采用非对称加密的方式交换「会话秘钥」，后续就不再使用非对称加密。
   - 在通信过程中全部使用「会话秘钥」进行**对称加密**来加密明文数据。

2. *摘要算法 + 数字签名*

   **摘要算法（哈希函数）来计算出内容的哈希值**，也就是内容的「指纹」，这个**哈希值是唯一的，且无法通过哈希值推导出内容**。通过哈希算法可以确保内容不会被篡改，**但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明**。将哈希值进行私钥加密就得到了**数字签名**。具体流程如下：

   服务端会对传输的明文数据进行哈希运算得到哈希值A，然后使用私钥加密得到数字签名，然后将数字签名以及传输的数据一同发出去，客户端收到后，对收到的数据进行哈希运算得到哈希值B，对数字签名使用公钥解密得到哈希值A，对比A和B，如果相同则证明消息是完整的，否则消息在传输过程中被篡改。私钥是由服务端保管，然后服务端会向客户端颁发对应的**公钥**（后续使用数字证书）。如果客户端收到的信息，能被公钥解密，就说明该消息是由服务器发送的。![摘要算法](.\pic\摘要算法.png)

3. *数字证书*

​	由于2中的公钥可能被伪造替换，因此需要认证机构对公钥进行认证，因此就有了CA机构。服务器将自己的公钥注册到CA，CA用自己的私钥将服务器的公钥进行数字签名并颁发数字证书，客户端拿到服务器端的数字证书就可以用CA的公钥（已经保存在计算机或浏览器中）确认服务器数字证书的真实性。通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。

![摘要算法](.\pic\CA.png)

#### HTTPS的连接过程

TLS 协议建立的详细流程：

*1. ClientHello*：客户端发起连接请求，发送以下消息：1.客户端支持的TLS版本号，2.客户端生成的随机数（`Client Random`），后面用于生成「会话秘钥」条件之一。3.客户端支持的密码套件列表，如 RSA 加密算法。

*2. SeverHello*：服务端收到客户端请求后，发出响应：1.确认TLS版本号，2.服务端生成的随机数（`Server Random`），3.确认密码套件列表，4.服务器端的数字证书。

*3.客户端回应*：首先客户端会利用CA公钥来验证数字证书的真实性，然后取出数字证书中的公钥，用于加密报文，并向服务器端发送：1.一个随机数（`pre-master key`）。该随机数会被服务器公钥加密。2.加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。3.客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。

**服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」**。

*4. 服务器的最后回应*：1.加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。2.服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。

#### HTTP/1.0和HTTP/1.1的区别

- **连接方式**： HTTP/1.0 为短连接，HTTP/1.1 支持长连接。

- **状态响应码** ：HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，`100 (Continue)`——在请求大资源前的预热请求，`206 (Partial Content)`——范围请求的标识码，`409 (Conflict)`——请求与当前资源的规定冲突，`410 (Gone)`——资源已被永久转移，而且没有任何已知的转发地址。
- **缓存机制** ：在 HTTP/1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP/1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。
- **带宽**：HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
- **Host 头（Host Header）处理**：HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能。而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。

#### HTTP/1.1和HTTP/2.0的区别

- **多路复用（Multiplexing）**：HTTP/2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP/1.1 中长链接的升级版本），互不干扰。HTTP/1.1 则使用串行方式，每个请求和响应都需要独立的连接，而浏览器为了控制资源会有 6-8 个 TCP 连接都限制。。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。

- **二进制帧（Binary Frames）**：HTTP/2.0 使用二进制帧进行数据传输，而 HTTP/1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。

- **头部压缩（Header Compression）**：HTTP/1.1 支持`Body`压缩，`Header`不支持压缩。HTTP/2.0 支持对`Header`压缩，使用了专门为`Header`压缩而设计的 HPACK 算法，减少了网络开销。

- **服务器推送（Server Push）**：HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。

#### HTTP/2.0和HTTP/3.0的区别

- **传输协议**：HTTP/2.0 是基于 TCP 协议实现的，HTTP/3.0 底层改为了UPD实现，新增了 QUIC（Quick UDP Internet Connections） 协议来实现可靠的传输，提供与 TLS/SSL 相当的安全性，具有较低的连接和传输延迟。
- **队头阻塞**：HTTP/2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP/3.0 在一定程度上解决了队头阻塞（Head-of-Line blocking, 简写：HOL blocking）问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。

### HTTP 是不保存状态的协议, 如何保存用户状态?

HTTP是一种无状态（stateless）协议，即它不存储用户状态。如果要存储用户状态，典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。因此Session机制就是解决这个问题。服务器端给特定用户创建一个特定给的session用于跟踪用户（一般有个过期时间），客户端只需要在cookie中添加sessionID即可被服务器识别。

### PING 命令

PING命令是基于网络层的ICMP，主要原理是在网络上发送和接受ICMP报文，分为：

- ICMP查询报文：向目标主机发送请求并期望得到响应。
- ICMP差错报文：向源主机发送错误报文，报告网络错误情况。

### TCP 与 UDP的区别

1. **是否面向连接**：TCP是面向连接的服务，在传输数据前需要建立连接，而UDP不需要。
2. **是否可靠传输**：接收方在接受UDP报文后，不需要给出任何确认，不保证数据不丢失，也不保证数据按序到达。TCP依靠确认，流量窗口、超时重传、拥塞控制机制保证数据的可靠传输。
3. **是否有状态**：TCP是有状态的，会记录报文是否被接收等，而UDP是无状态的，无脑发送。
4. **是否提供广播或多播服务**：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；
5. **传输形式**：TCP 是面向字节流的，UDP 是面向报文的。

### 应用层常见协议

#### HTTP：超文本传输协议

HTTP协议是基于TCP的协议。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。

#### SMTP：简单邮件传输(发送)协议 && POP3/IMAP：邮件接收的协议

SMTP用于发送邮件，POP3用于接收邮件，具体流程如下：1.通过SMTP协议将我的邮件发送给我的邮箱服务器，如163邮箱服务器，163邮箱服务器发现我的接收方是qq邮箱，则将我的邮件转发到qq邮箱服务器；qq邮箱服务器再通知目标用户来接收邮件，然后用户就通过 **POP3/IMAP** 协议将邮件取出。

#### FTP:文件传输协议

**FTP 协议** 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。其独特优势在于它与服务器建立了两条TCP连接：

1. 控制连接：用于传输控制消息；
2. 数据连接：用于传输文件数据。

FTP是不安全的协议，因此可以使用SFTP，一种基于 SSH 协议的安全文件传输协议，用于在网络上安全地传输文件。

#### DNS:域名系统

DNS（Domain Name System）是一种用于将域名解析为IP地址的分布式命名系统。它充当了互联网上域名和IP地址之间的转换器。下面简要阐述DNS的流程：

当用户输入一个域名如“www.baidu.com”，操作系统会在本地缓存中查找该域名对应的IP，如果没有则向本地域名服务器查询。本地域名服务器查询本地缓存中是否有目标域名对应的IP地址，如果有则返回，没有将会向根DNS服务器发出查询请求。根DNS服务器会根据查询的顶级域（如.com、.org等）返回对应的顶级域DNS服务器的IP地址。本地DNS服务器继续向顶级域DNS服务器发送请求。顶级域DNS服务器根据请求返回次级域名服务器的IP地址，本地DNS服务器继续向返回的次级域名服务器发送请求，反复重复该过程，直到找到负责该域名的权威DNS服务器。权威DNS服务器返回查询结果给本地DNS服务器，本地DNS服务器将结果缓存并返回操作系统。

#### ARP：**地址解析协议**

ARP（地址解析协议）是一个用于将网络上的IP地址转换为MAC地址的协议。下面是其工作流程：

源设备想要发送数据给目标设备时，会查询本地ARP缓存表，如果本地缓存表没有，源设备就会广播一个ARP请求帧到本地网络上的所有设备，所有收到该帧的设备会对比目标IP地址与自己的IP地址是否对应，如果匹配则发送ARP响应给源设备，响应中包含目标设备的IP地址，源设备收到该响应后，会缓存目标设备IP地址和MAC地址的映射关系。

#### NAT：网络地址转换协议

NAT的提出是为了解决ipv4地址不足问题，用于在内网和外网之间进行地址转换。以下是工作流程：

主机A要发送数据到主机B时，会指派一个端口作为源端口，并将该请求发往路由器中。路由器收到请求后，会重新指派一个新的端口，并将报文发往wan接口，同时在NAT记录表中记录内网IP：端口和外网IP：端口的映射关系。路由器收到主机B发送响应报文后，会根据NAT记录表中的映射关系发送到内网的主机A上。

#### TCP 如何保证传输的可靠性？

1. 数据包的排序与去重：TCP为每个包分配了一个序号，可以根据序号对非按序到达的数据包排序并去重。
2. 校验和：TCP有一个校验和字段，当客户端收到数据包后会重新计算校验和并于收到的校验和对比，如果不同则丢弃该报文。
3. 超时重传：发送方发送完数据后会启动一个定时器，当发送方在合理的往返时延RTT内未收到数据包的确认，则会重新发送该数据包。
4. 流量控：TCP连接的每一方都有固定大小的缓冲空间，TCP接收端只允许发送端发送接收缓冲区允许接纳的数据包。当接收方来不及处理收到的报文时，能够通知发送方降低发送速率。
5. 拥塞控制：当网络拥塞时，减少数据的发送。