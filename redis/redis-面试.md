## 数据类型篇

#### String

![string](.\ref\string.png)

**应用场景：**

- 常规计数：计算文章的阅读量

- 分布式锁：SET 命令有个 NX 参数可以实现「key不存在才插入」，可以用它来实现分布式锁：

  - 如果 key 不存在，则显示插入成功，可以用来表示加锁成功；

  - 如果 key 存在，则会显示插入失败，可以用来表示加锁失败。

  - ```shell
    SET lock_key unique_value NX PX 10000
    ```

  - lock_key 就是 key 键；

  - unique_value 是客户端生成的唯一的标识；

  - NX 代表只在 lock_key 不存在时，才对 lock_key 进行设置操作；

  - PX 10000 表示设置 lock_key 的过期时间为 10s，这是为了避免客户端发生异常而无法释放锁。

而解锁的过程就是将 lock_key 键删除，但不能乱删，要保证执行操作的客户端就是加锁的客户端。所以，解锁的时候，我们要先判断锁的 unique_value 是否为加锁客户端，是的话，才将 lock_key 键删除。

可以看到，解锁是有两个操作，这时就需要 Lua 脚本来保证解锁的原子性，因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，保证了锁释放操作的原子性。

- 共享Session 信息

#### List

![List](.\ref\List.png)

#### Hash

Hash 是一个键值对（key - value）集合，其中 value 的形式如： `value=[{field1，value1}，...{fieldN，valueN}]`。Hash 特别适合用于存储对象。![hash](.\ref\hash.png)

**应用场景：**

- 缓存对象：Hash 类型的 （key，field， value） 的结构与对象的（对象id， 属性， 值）的结构相似，也可以用来存储对象。
- 购物车：以用户 id 为 key，商品 id 为 field，商品数量为 value，恰好构成了购物车的3个要素。

#### Set

Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。![set](.\ref\set.png)

**应用场景：**

- **点赞：**Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章id，value 是用户id。
- **共同关注：**Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。
- **抽奖活动：** 存储某活动中中奖的用户名 ，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。key为抽奖活动名，value为员工名称，把所有员工名称放入抽奖箱。如果允许重复中奖，可以使用 SRANDMEMBER 命令。如果不允许重复中奖，可以使用 SPOP 命令。

#### Zset

Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序集合的元素值，一个是排序值。![zset](.\ref\zset.png)

**应用场景：**

- **排行榜：**我们以博文点赞排名为例，小林发表了五篇博文，分别获得赞为 200、40、100、50、150。文章 arcticle:4 新增一个赞，可以使用 ZINCRBY 命令（为有序集合key中元素member的分值加上increment）：

#### BitMap

Bitmap，即位图，是一串连续的二进制数组（0和1），可以通过偏移量（offset）定位元素。BitMap通过最小的单位bit来进行`0|1`的设置，表示某个元素的值或者状态，时间复杂度为O(1)。

![zset](.\ref\bitmap.png)

**应用场景：**

- **签到统计：**每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。
- **判断用户登录状态：**Bitmap 提供了 `GETBIT、SETBIT` 操作，通过一个偏移值 offset 对 bit 数组的 offset 位置的 bit 位进行读写操作，需要注意的是 offset 从 0 开始。我们将用户ID作为offset，在线就设为1，下线就设为0。通过 `GETBIT`判断对应的用户是否在线。 5000 万用户只需要 6 MB 的空间。

- **连续签到用户总数：**如何统计出这连续 7 天连续打卡用户总数呢？一共有7个BitMap，我们将这7个BitMap做与运算，当一个 userID 在 7 个 Bitmap对应的 offset 位置的 bit = 1 就说明该用户 7 天连续打卡。

#### HyperLogLog

一种用于「统计基数」的数据集合类型，基数统计就是指统计一个集合中不重复的元素个数。但要注意，HyperLogLog 是统计规则是基于概率完成的，不是非常准确，标准误算率是 0.81%。

在 Redis 里面，**每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 `2^64` 个不同元素的基数**，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。

**应用场景：**

- 百万级网页 UV 计数：百万级网页 UV 计数。在统计 UV 时，你可以用 PFADD 命令（用于向 HyperLogLog 中添加新元素）把访问页面的每个用户都添加到 HyperLogLog 中。接下来，就可以用 PFCOUNT 命令直接获得 page1 的 UV 值了，这个命令的作用就是返回 HyperLogLog 的统计结果。

#### GEO

主要用于存储地理位置信息，并对存储的信息进行操作。GEO 类型使用 GeoHash 编码方法实现了经纬度到 Sorted Set 中元素权重分数的转换，这其中的两个关键机制就是「对二维地图做区间划分」和「对区间进行编码」。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为 Sorted Set 元素的权重分数。

**应用场景：**

- 滴滴打车：假设车辆 ID 是 33，经纬度位置是（116.034579，39.030452），我们可以用一个 GEO 集合保存所有车辆的经纬度，集合 key 是 cars:locations。

## 持久化篇

#### AOF**(Append Only File)** 

Redis 每执行一条写操作命令，就把该命令以追加的方式写入到一个AOF文件中，然后重启 Redis 的时候，先去读取这个AOF文件里的命令，并且执行它，从而恢复缓存数据

**三中写回策略：**

- **Always**，这个单词的意思是「总是」，所以它的意思是每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；
- **Everysec**，这个单词的意思是「每秒」，所以它的意思是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；
- **No**，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。

**AOF重写机制：**

AOF 日志是一个文件，随着执行的写操作命令越来越多，文件的大小会越来越大。举个例子，在没有使用重写机制前，假设前后执行了「*set name xiaolin*」和「*set name xiaolincoding*」这两个命令的话，就会将这两个命令记录到 AOF 文件。但是**在使用重写机制后，就会读取 name 最新的 value（键值对） ，然后用一条 「set name xiaolincoding」命令记录到新的 AOF 文件**，

Redis 的**重写 AOF 过程是由后台子进程 bgrewriteaof 来完成的。**![COW](.\ref\COW.png)

- 子进程和父进程一开始共享一段物理内存，当父进程或子进程需要修改内存里的值时，就会发生**物理内存的复制**，并重新设置其内存映射关系。这个过程被称为「**写时复制(*Copy On Write*)**」，顾名思义：**在发生写操作的时候，操作系统才会去复制物理内存**。

- 触发重写机制后，主进程就会创建重写 AOF 的子进程，此时父子进程共享物理内存，重写子进程只会对这个内存进行只读，重写 AOF 子进程会读取数据库里的所有数据，并逐一把内存数据的键值对转换成一条命令，再将命令记录到重写日志（新的 AOF 文件）。

- 但是子进程重写过程中，主进程依然可以正常处理命令。如果此时**主进程修改了已经存在 key-value，就会发生写时复制，注意这里只会复制主进程修改的物理内存数据，没修改物理内存还是与子进程共享的**。

- AOF 文件重写期间，Redis 还会维护一个 **AOF 重写缓冲区**，该缓冲区会在子进程重写期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作



#### RDB（redis默认的持久化机制）

redis通过创建快照来获取内存中的数据在某个时间节点的副本。Redis 提供了两个命令来生成 RDB 文件，分别是 `save` 和 `bgsave`，他们的区别就在于是否在「主线程」里执行：

- 执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，**会阻塞主线程**；
- 执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以**避免主线程的阻塞**；

**问题：**在gbsave的过程中，如果主线程修改了共享数据，发生写时复制后，RDB快照保存的是旧的数据，因此更新的数据只能交由下一次生成的快照来写入RDB文件。

#### RDB与AOF混合

由RDB来存储全量数据，由AOF来记录gbsave过程中主线程修改的内存值。

## 功能篇

#### 过期删除策略

Redis 可以对 key 设置过期时间，因此需要有相应的机制将已过期的键值对删除，而做这个工作的就是过期键值删除策略。Redis会维护一个过期字典，字典实际上是哈希表，value就是过期时间。当我们查询一个 key 时，Redis 首先检查该 key 是否存在于过期字典中：

- 如果不在，则正常读取键值；
- 如果存在，则会获取该 key 的过期时间，然后与当前系统时间进行比对，如果比系统时间大，那就没有过期，否则判定该 key 已过期。

<img src=".\ref\过期时间.png" alt="过期时间" style="zoom: 50%;" />

- 定时删除:
  - 定时删除策略的做法是，**在设置 key 的过期时间时，同时创建一个定时事件，当时间到达时，由事件处理器自动执行 key 的删除操作。**
  - 优点：保证过期key尽快被删除，腾出内存空间。
  - 缺点：过期key较多时，删除过期key可能占用相当一部分时间，十分占用cpu资源。
- 惰性删除
  - 惰性删除策略的做法是，**不主动删除过期键，每次库访问 key 时，都检测 key 是否过期，如果过期则删除该 key。**
  - 优点：删除策略只占用一部分的cpu时间，cpu友好
  - 缺点：大量过期key不被访问的话，那么他们都会堆积在内存中，浪费内存空间。
- 定期删除
  - 定期删除策略的做法是，**每隔一段时间「随机」从数据库中取出一定数量的 key 进行检查，并删除其中的过期key。**
  - 优点：通过限制删除操作执行的时长和频率，来减少删除操作对 CPU 的影响，同时也能删除一部分过期的数据减少了过期键对空间的无效占用。
  - 缺点：内存清理方面没有定时删除效果好，同时没有惰性删除使用的系统资源少。

**Redis 选择「惰性删除+定期删除」这两种策略配和使用**，

#### 内存淘汰策略

当 Redis 的运行内存已经超过 Redis 设置的最大内存之后，则会使用内存淘汰策略删除符合条件的 key，以此来保障 Redis 高效的运行。