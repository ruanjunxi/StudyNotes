#### 包装类型的缓存机制了解么？

Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。

####  自动装箱与拆箱了解吗？原理是什么？

装箱：`Integer i = Integer.valueOf(10)`；

拆箱：`int n = i.intValue()`;

#### 静态方法为什么不能调用非静态成员?

- 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。非静态成员方法是属于实例对象的，只有在创建实例对象的时候才分配内存，需要通过实例对象去访问；
- 如果直接使用静态方法去访问非静态成员，可能会出现非静态成员还没被分配内存就被访问的情况，因此直接禁止这种情况发生。

####  什么是可变长参数？

所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 `printVariable` 方法就可以接受 0 个或者多个参数。

```java
public static void method2(String arg1, String... args) {
   //......
}
```

**遇到方法重载的情况时**，会优先匹配固定参数的方法。

#### 接口和抽象类有什么共同点和区别？

- 共同点：
  - 都不能被实例化
  - 都可以包含抽象方法
  - 都可以有默认实现的方法
- 区别：
  - 定义：接口是一种完全抽象的类，其中所有的方法都是抽象的，并且默认是公共的。抽象类是一个可以包含抽象方法和具体方法的类，其目的是为了被子类继承和拓展。
  - 一个类只能继承另一个类，但可以实现多个接口；
  - 接口一般是对类进行约束，实现了接口就具有了对应的功能。抽象类主要用于代码的复用。
  - 接口中的成员变量只能是 `public static final` 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。
- 如何选择
  - 如果类之间存在“is-a”关系（继承关系），并且子类与父类之间有共性的行为和属性，适合使用抽象类。抽象类可以提供共性的方法实现，子类只需要实现特定的抽象方法。
  - 如果类之间存在“has-a”关系（关联关系），并且类需要遵循多个不同的规范，适合使用接口。接口可以定义不同的规范，一个类可以实现多个接口，从而实现多重继承。
  - 如果想要提供一组通用的功能，而这些功能可能不同类之间没有直接的继承关系，可以考虑使用接口。接口允许不同类实现相同的接口，以达到代码重用和多态性的目的


#### 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？

- 深拷贝：完全拷贝一个对象，包括其内部对象
- 浅拷贝：拷贝一个对象，如果其中有内部对象的引用的话，浅拷贝就会直接复制内部对象的引用地址。（外对象拷贝，内对象拷贝引用地址）
- 引用拷贝：不会在堆上创建对象，只会复制对象的引用。即对象还是只有一个，只不过多了个引用指向该对象。

#### 为什么重写 equals() 时必须重写 hashCode() 方法？

如果重写equals()方法时没有重写hashCode()方法，那么有可能出现equals()方法判断两个对象是相同的，但是其hashCode却不相同，这在使用`HashSet`和`HashMap`时会出现错误。

#### String 为什么是不可变的?

String是不可变的，低层使用`final` 来修饰字符数组，这就导致了其修饰的变量是引用类型则不能再指向其他对象。但其实字符数组是可以变的，但保存字符的数组被`final` 修饰，且是私有的，String并没有对外提供可变接口，从而导致其不可变。

#### 字符串常量池的作用了解吗？

**字符串常量池** 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。**其大小取决于可用内存的大小。**

#### String#intern 方法有什么作用?

使用`String.intern()`方法可以实现字符串的共享和节省内存。当我们需要频繁地比较字符串内容时，通过使用`intern`方法，可以确保相同内容的字符串共享同一个引用，从而提高比较效率。此外，由于字符串常量池中的字符串对象是唯一的，因此可以减少内存占用，特别是当存在大量重复字符串时。以下是简单案例：

```java
String s1 = new String("Hello"); // 创建一个新的字符串对象
String s2 = "Hello"; // 字符串常量池中已经存在"Hello"，返回常量池中的引用

System.out.println(s1 == s2); // 输出false，s1和s2引用的是不同的对象

String s3 = s1.intern(); // 将s1添加到字符串常量池中，并返回常量池中的引用

System.out.println(s2 == s3); // 输出true，s2和s3引用的是同一个对象

```

####  Checked Exception 和 Unchecked Exception 有什么区别？

- **Checked Exception** 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 `catch`或者`throws` 关键字处理的话，就没办法通过编译。除了`RuntimeException`及其子类以外，其他的`Exception`类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、`ClassNotFoundException`、`SQLException`...。
- **Unchecked Exception** 即 **不受检查异常** ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。`RuntimeException` 及其子类都统称为非受检查异常： 
  - `NullPointerException`(空指针错误)
  - `IllegalArgumentException`(参数错误比如方法入参类型错误)
  - `NumberFormatException`（字符串转换为数字格式错误，`IllegalArgumentException`的子类）
  - `ArrayIndexOutOfBoundsException`（数组越界错误）
  - `ClassCastException`（类型转换错误）
  - `ArithmeticException`（算术错误）
  - `SecurityException` （安全错误比如权限不够）
  - `UnsupportedOperationException`(不支持的操作错误比如重复创建同一用户)

#### 泛型

**泛型的作用：**泛型主要作用是在编译时提供类型安全性，同时使得代码更通用，提高代码的可重用性。

**类型擦除：**

**泛型的限制：**1.不能使用基本数据类型作为泛型参数，2.不能创建参数化类型的数组，3.不能直接捕获泛型类的异常（可以使用通配符捕获）。

**常用的通配符：**

- 问号通配符（?）：表示未知类型。可以用作方法的参数类型、返回类型或变量声明中的通配符。
- 上界通配符（extends）：用于限制通配符只能匹配指定类及其子类。
- 下界通配符（super）：用于限制通配符只能匹配指定类及其父类。

泛型一般有三种使用方式:**泛型类**、**泛型接口**、**泛型方法**。

```java
//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic<T>{

    private T key;

    public Generic(T key) {
        this.key = key;
    }

    public T getKey(){
        return key;
    }
}

//2. 泛型接口
public interface Generator<T> {
    public T method();
}
// 实现泛型接口不指定类型
class GeneratorImpl<T> implements Generator<T>{
    @Override
    public T method() {
        return null;
    }
}
// 实现泛型接口指定类型
class GeneratorImpl<T> implements Generator<String>{
    @Override
    public String method() {
        return "hello";
    }
}
//3. 泛型方法

public static <E> void Print(E[] arrayToPrint){
    for(E element:arrayToPrint){
        System.out.printf( "%s ", element );
    }
     System.out.println();
}
```

**项目中使用泛型的地方：**

- 自定义接口通用返回结果 `CommonResult<T>` 通过参数 `T` 可根据具体的返回类型动态指定结果的数据类型
- 定义 `Excel` 处理类 `ExcelUtil<T>` 用于动态指定 `Excel` 导出的数据类型
- 构建集合工具类（参考 `Collections` 中的 `sort`, `binarySearch` 方法）。

#### 反射

我理解反射是一种强大的特性，它让Java程序在运行时具有更高的灵活性和可扩展性。通过反射，我们可以在运行时动态地加载和使用类，调用方法，访问属性等。这为编写通用的、灵活的代码和设计可扩展的系统提供了可能性。然而，反射也有一定的性能开销和安全隐患，因此在使用反射时需要慎重考虑。

**框架为什么需要反射：** 在框架开发中，通常需要处理不同的对象和类，而这些对象和类的具体类型在编译时可能并不确定。通过反射，框架可以在运行时动态地加载和使用类，实现对象的创建、调用方法、访问属性等功能。这使得框架能够处理各种类型的对象，并根据配置或条件来决定具体使用哪些类。例如，Spring框架使用反射实现依赖注入，可以动态地将实例化的对象注入到其他对象中，而无需在代码中硬编码依赖关系。总的来说，反射为框架提供了更高的灵活性和可扩展性，使得框架能够更加通用和适应不同的业务场景。

#### 代理模式

我们使用代理对象来代替对真实对象的访问，代理模式的目的是为了扩展目标对象的功能，例如在执行方法前后增加一些动作。

##### 静态代理：

- **静态代理中，我们对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改）且麻烦(需要对每个目标类都单独写一个代理类）。** 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。

- 静态代理实现步骤：
  - 定义一个接口以及实现类
  - 创建一个代理类同时实现该接口
  - 将目标对象注入进代理类，并在需要执行方法的地方插入目标对象中对应的方法，从而屏蔽对目标对象的访问而直接访问了目标对象的方法。

##### 动态代理：

- **从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的**
- 包括： **JDK 动态代理**、**CGLIB 动态代理**

#### SPI

Java的SPI（Service Provider Interface）是一种用于实现插件化架构的机制。它允许应用程序定义一个接口，并通过该接口发现和加载其服务的实现。

SPI的使用场景包括：

1. 扩展框架：Java SPI可以被用于扩展各种框架，例如数据库连接驱动、日志系统等。框架通过提供一个标准的接口，允许开发者编写自己的实现并通过SPI加载到框架中。
2. 业务组件：在复杂的应用程序中，不同的业务组件可能需要根据配置或运行时需求来选择合适的实现。使用SPI，可以在运行时动态地加载和替换这些组件的实现。
3. 插件系统：SPI可以用于设计插件系统，使得应用程序可以加载和管理外部插件。通过定义插件接口并提供相应的SPI实现，应用程序可以动态地加载插件，并在运行时执行相应的功能。

Java的SPI机制基于以下几个关键元素：

- Service Provider Interface (SPI)：定义了服务接口，通常以接口的形式存在。
- Service Provider：实现了SPI接口的具体实现类，通过SPI配置文件注册。
- SPI配置文件：在`META-INF/services/`目录下，以服务接口的全限定名为文件名，内容为具体实现类的全限定名。

#### 什么是序列化和反序列化?

- 序列化：将数据结构或对象转换为可传输的二进制字节流；
- 反序列化：序列化的逆过程

常见应用场景：

- 对象要进行网络传输时，要先进行序列化。
- 将对象存储到文件或数据库中时要进行序列化，从文件中读取要进行反序列化；

JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 `Hessian`、`Kryo`、`Protobuf`、`ProtoStuff`，这些都是基于二进制的序列化协议。

综上：**序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。**

**serialVersionUID 有什么作用？**

序列化号`serialVersionUID `属于版本控制的作用。反序列化时，会检查反序列化得到的`serialVersionUID ` 和当前类的`serialVersionUID ` 是否相同，如果不同则会抛出`InvalidClassException` 异常。强烈建议为每个序列化类手动指定`serialVersionUID`， 使用`static final long `来修饰。

#### Java 魔法类 Unsafe 详解

